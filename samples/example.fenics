// Define a fixed variable:

const unmutableVariable: 42; // Detects an Integer

// Define a mutable variable:
mutableVariable: "Hello, World!"; // Detects a String

// Define variables with explicit types:

String explicitMutable: "Explicitly typed mutable string";
Int const explicitUnmutable: 100;
Float explicitFloat: 3.14;
Boolean explicitBoolean: true;
List(Int) numberList: [1, 2, 3, 4, 5];
Pairs(String, Float) priceList:
    - "apple": 0.99,
    - "banana": 0.59

// Define an object with properties:

person:
    - name: "Alice",
    - age: 30,
    - isStudent: false

// Create a function

fn greet(name: String) -> String:
    return "Hello, #{name}!"

// Functions and variables are global by default when it is at the top level.
// Otherwise, it is local to the block where it is defined.
// You can use 'global' keyword to define a global variable inside a block.

fn demonstrateScope():
    global mut scopedVariable: "I am global variable"
    mut localVariable: "I am a local variable"

// Commented out to avoid runtime error since demonstrateScope() is never called
// fn furtherUse():
//     // Access the global variable defined in demonstrateScope
//     print(scopedVariable) // Should print: I am global variable
//     // print(localVariable) // This would cause an error since localVariable is not accessible here

// Built-in function usage:

// String properties and functions

nameLength: "Sample Name".length // Should return 11
splittedName: "First Last".split(" ") // Should return ["First", "Last"]

// List properties and functions
numbers: [10, 20, 30, 40, 50];
firstNumber: numbers.first // Should return 10
lastNumber: numbers.last // Should return 50
reversedNumbers: numbers.reverse() // Should return [50, 40, 30, 20, 10]
sortedNumbers: [3, 1, 4, 2].sort("0-9") // Should return [1, 2, 3, 4]
reversedSortedNumbers: [3, 1, 4, 2].sort("9-0") // Should return [4, 3, 2, 1]
sortedWords: ["banana", "apple", "cherry"].sort("a-z") // Should return ["apple", "banana", "cherry"]
reversedSortedWords: ["banana", "apple", "cherry"].sort("z-a") // Should return ["cherry", "banana", "apple"]
hasNumber20: numbers.has(20) // Should return true


// Object properties and functions

personKeys: person.keys() // Should return ["name", "age", "isStudent"]

person["height"]: 170 // Adding a new property to the object
person.age +: 1 // Incrementing the age property by 1
person.newProperty: "New Value" // Adding another property; same as person["newProperty"]: "New Value"



// Utilities and iterations

for _, v in person:
    print("#{v}")

for i in numbers:
    print("#{i}")

// Simple if condition

if explicitBoolean:
    print("The explicitBoolean is true")

// Simple if-else conditions

if explicitBoolean:
    print("The explicitBoolean is true")
else:
    print("The explicitBoolean is false")


// If-else-elseif conditions 

test: null // Define test as null for demonstration

Boolean test = false


if test is null:
    print("test is null")
else if test is undefined:
    print("test is undefined")
else if test is NaN:
    print("test is NaN")
else:
    print("test has a valid value")


// We can "pass" or block the next effect, like "return" in javascript but we can use it anywhere.

// Not yet implemented:
// if thisIsTrue: block print ("This will be printed because thisIsTrue is true, but block prevents further effects.")

// Multiple conditions can be done easily, "and" can be written in different ways.

bool: true
bool2: true
if bool and bool2:
    print("Both bool and bool2 are true")

// Ephemeral variables can be used in conditions.
// We can also create a local variable inside the condition to retrieve ephemeral values.

if explicitFloat#tempVar > 3.0:
    print("explicitFloat is greater than 3.0, value: #{tempVar}")

// If not need to reuse in the scope, but just in the condition, use numbers instead.

if explicitFloat#1 > 3.0 and #1 < 4.0:
    print("explicitFloat is greater than 3.0 and less than 4.0")

// Ternary operator is also supported (not yet implemented).
// result: if explicitBoolean then "It's true!" otherwise "It's false!"
// result2: explicitBoolean ? "It's true!" : "It's false!"

// A loop that always runs but activates only when the condition is met.

loop explicitBoolean:
    print("This will print repeatedly as long as explicitBoolean is true.")

// While loop: Will run as long as the condition is true and stops when it becomes false.

mut count: 0;
while count < 5:
    print("Count is: #{count}")
    count++ // can be written as "count: count + 1" or "count +: 1"


// Error handling with try-catch

try:
    mut riskyVariable: 10 / 2 // This will cause a division by zero error
    print("Risky variable value: #{riskyVariable}")
catch (err):
    print("An error occurred: #{err.message}")


// Properties of the Error object are:
// err.message: The error message
// err.type: The type of error
// err.stack: The stack trace of the error
// err.line: The line number where the error occurred
// err.column: The column number where the error occurred
// err.file: The file where the error occurred
// err.origin: The file where the error "has been called"
